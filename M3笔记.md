# 面向对象

#### 对象和`__init__`

在每个类中都可以定义个特殊的：`__init__ 初始化方法 `，在实例化类创建对象时自动执行，即：`对象=类()`。

```python
class Message:

    def __init__(self, content):
        self.data = content

    def send_email(self, email):
        data = "给{}发邮件，内容是：{}".format(email, self.data)
        print(data)

    def send_wechat(self, vid):
        data = "给{}发微信，内容是：{}".format(vid, self.data)
        print(data)

# 对象 = 类名() # 自动执行类中的 __init__ 方法。

# 1. 根据类型创建一个对象，内存的一块 区域 。
# 2. 执行__init__方法，模块会将创建的那块区域的内存地址当self参数传递进去。    往区域中(data="注册成功")
msg_object = Message("注册成功")

msg_object.send_email("wupeiqi@live.com") # 给wupeiqi@live.com发邮件，内容是：注册成功
msg_object.send_wechat("武沛齐") # 给武沛齐发微信，内容是：注册成功
```

- 对象object：让我们可以在它的内部先封装一部分数据，以后想要使用时，再去里面获取。基于类实例化出的一块内存区域，默认里面没有任何数据，通过调用`__init__`初始化数据
- init：类中的方法需要这个类 的对象及性能触发才可以执行，且在执行时会自动将对象当做参数传递给self，以供方法中获取对象中已封装的值

- 面向对象的思想：将一些数据封装到一个对象中，在执行方法时，再去对象中获取。

- 常见成员：

  - 实例变量：属于对象，只有通过对象调用

  - 绑定方法：属于类，通过对象调用或者类调用

    ```python
    class Student:
      def __init__(self,n1,n2):
        #实例变量
        self.n1 = n1
        self.n2 = n2
      def show(self):#绑定方法
        print(self.n1)
        
    s = Student('ivan','lee')
    s.show()#通过对象调用绑定方法
    Student.show(s)# 通过类调用
    ```

    

### 三大特性：封装，继承，多态

#### 封装

封装主要体现在两个方面：

- 将同一类方法封装到了一个类中
- 将数据封装到了对象中，在实例化一个对象时，可以通过`__init__`初始化方法在对象中封装一些数据，便于以后使用。

#### 继承

子类可以继承父类中的方法和类变量（不是拷贝一份，父类的还是属于父类，子类可以继承而已）。

```python
class Base:
    def f1(self):
        print('base.f1')
        
class Foo(Base):
    def f2(self):
        print('foo.f2')
        
obj = Foo()
obj.f1()
obj.f2()
>>>	base.f1
		foo.f2
```

```python
class Base:
    def f1(self):
        print('base.f1')
        
class Foo(Base):
    def f2(self):
        print('before')
        self.f1() # 调用了f1方法   obj.f1()
        print('foo.f2')
        
obj = Foo()
obj.f2()
>>> before
		base.f1
		foo.f2
```

```python
class Base:
    def f1(self):
        print('base.f1')
        
class Foo(Base):
    def f2(self):
        print("before")
        self.f1() # obj,Foo类创建出来的对象。 obj.f1
        print('foo.f2')
	  		def f1(self):  #未被调用
        		print('foo.f1')
        
obj = Foo()
obj.f1() # obj对象到底是谁？优先就会先去谁里面找。
obj.f2()
>>> base.f1
		before
		base.f1
		foo.f2
```

```python
class Base:
    def f1(self):
        print('base.f1')


class Foo(Base):
    def f2(self):
        print("before")
        self.f1()  # obj,Foo类创建出来的对象。 obj.f1
        print('foo.f2')
    def f1(self):
        print('foo.f1')
obj = Foo()
obj.f1() # obj对象到底是谁？优先就会先去谁里面找。
obj.f2()
>>>	foo.f1
		before
		foo.f1
		foo.f2
```

#### 多态

在`java`或其他语言中的多态是基于：接口 或 抽象类和抽象方法来实现，让数据可以以多种形态存在。

在`Python`中则不一样，由于Python对数据类型没有任何限制，所以他天生支持多态。

### 面向对象的所有成员

- 变量
  - 实例变量：属于对象，每个对象各自维护的数据
  - 类变量：属于类，可以被所有对象共享，一般用于给对象提供公共数据（类似于全局变量）

- 方法
  - 绑定方法
  - 类方法
  - 静态方法

```python
class Person(object):
    country = "中国"   --> 类变量
    def __init__(self, name, age):
        self.name = name  --> 实例变量
        self.age = age

    def show(self):
        message = "{}-{}-{}".format(self.country, self.name, self.age)
        print(message)

print(Person.country) # 中国


p1 = Person("ivan",20)
print(p1.name)
print(p1.age)
print(p1.country) # 中国

p1.show() # 
```

```python
class Base(object):
    country = "中国"

class Person(Base):

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def show(self):
        message = "{}-{}-{}".format(Person.country, self.name, self.age)
        # message = "{}-{}-{}".format(self.country, self.name, self.age)
        print(message)
# 读
print(Base.country) # 中国
print(Person.country) # 中国

obj = Person("武沛齐",19)
print(obj.country) # 中国

# 写
Base.country = "china"
Person.country = "泰国"
obj.country = "日本"
```

面试题

```python
class Parent(object):
    x = 1
class Child1(Parent):
    pass
class Child2(Parent):
    pass
print(Parent.x, Child1.x, Child2.x) 
Child1.x = 2
print(Parent.x, Child1.x, Child2.x) 
Parent.x = 3
print(Parent.x, Child1.x, Child2.x) 
>>>	1 1 1
    1 2 1
    3 2 3
```

#### 方法

- 绑定方法，默认有一个self参数，由对象进行调用（此时self就等于调用方法的这个对象）【对象&类均可调用】
- 类方法，默认有一个cls参数，用类或对象都可以调用（此时cls就等于调用方法的这个类）【对象&类均可调用】
- 静态方法，无默认参数，用类和对象都可以调用。【对象&类均可调用】

```python
class Foo(object):

    def __init__(self, name,age):
        self.name = name
        self.age = age

    def f1(self):
        print("绑定方法", self.name)

    @classmethod
    def f2(cls):
        print("类方法", cls)

    @staticmethod
    def f3():
        print("静态方法")
        
# 绑定方法（对象）
obj = Foo("ivanl",20)
obj.f1() # Foo.f1(obj)

# 类方法
Foo.f2()  # cls就是当前调用这个方法的类。（类）
obj.f2()  # cls就是当前调用这个方法的对象的类。
# 静态方法
Foo.f3()  # 类执行执行方法（类）
obj.f3()  # 对象执行执行方法
>>> 绑定方法 ivanl
		类方法 <class '__main__.Foo'>
    类方法 <class '__main__.Foo'>
    静态方法
    静态方法
```

- `classmethod`：修饰符对应的函数不需要实例化，不需要 `self `参数，但第一个参数需要是表示自身类的 `cls `参数，可以来调用类的属性，类的方法，实例化对象等。

- `staticmethod`：返回静态方法

  区别：

  `从它们的使用上来看`

  - @staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。
  - @classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。
  - @classmethod 是一个函数修饰符，它表示接下来的是一个类方法，而对于平常我们见到的则叫做实例方法。
     类方法的第一个参数cls，而实例方法的第一个参数是self，表示该类的一个实例。 
  - 普通对象方法至少需要一个self参数，代表类对象实例
  - 类方法有类变量cls传入，从而可以用cls做一些相关的处理。并且有子类继承时，调用该类方法时，传入的类变量cls是子类，而非父类。
     对于类方法，可以通过类来调用，就像Test.foo()，有点类似C＋＋中的静态方法, 也可以通过类的一个实例来调用，就像`Test().foo()`，这里`Test()`，写成这样之后它就是类的一个实例了。
  - 静态方法则没有，它基本上跟一个全局函数相同，一般来说用的很少
  
  ![image-20220410230014023](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220410230014023.png)

#### 属性

属性其实是由绑定方法 + 特殊装饰器 组合创造出来的，让我们以后在调用方法时可以不加括号 `@property`

```python
class Foo(object):
    def __init__(self, name):
        self.name = name
    def f1(self):
        return 123
    @property
    def f2(self):
        return 123
    @property
    def f3(self):
      return self.name
obj = Foo("ivan")
v1 = obj.f1()
print(v1) #123
v2 = obj.f2
print(v2) #123
v3 = obj.f3
print(v3) #ivan
```

```python
class Foo(object):
    def __init__(self,age):
        self._age = age
    @property
    def x(self):
        return self._age+5
f = Foo(5)
print(f.x) #10  
```

关于属性的编写有两种方式：

- 基于装饰器

  ```python
  class C(object):   
      @property
      def x(self):
          pass   
      @x.setter
      def x(self, value):
          pass
      @x.deleter
      def x(self):
  		pass
          
  obj = C()
  
  obj.x
  obj.x = 123
  del obj.x
  ```

​		`setter`：对要存入的数据进行预处理+设置可读属性(不可修改)，**.setter装饰器必须在@property装饰器的后面，且两个被修饰		的函数的名称必须保持一致，* 即为函数名称。

```python
class Foo(object):
    def __init__(self,age):
        self._age = age
    @property
    def x(self):
        pass
    @x.setter
    def x(self,n):
        self._age = n + 5
f = Foo(5)
f.x = 1
print(f._age) #6当执行 f.x = 1 时，@x.setter装饰器下的age函数会将数据+5后再存入类属性_age中，实现了存入前对数据的预处理。
```

```python
class Foo(object):
    def __init__(self,age):
        self._age = age
    @property
    def x(self):
        return  self._age + 1
    @x.setter
    def x(self,n):
        print("不能被修改")
f = Foo(5)
f.x = 1
print(f._age)
>>> 不能被修改
		5
```

属性名称不要和实例变量重名

![image-20220401180435337](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220401180435337.png)

### 成员修饰符

Python中成员的修饰符就是指的是：公有、私有。

- 公有，在任何地方都可以调用这个成员。
- 私有，只有在类的内部才可以调用改成员（成员是以两个下划线开头，则表示该成员为私有）。

```python
class Foo(object):

    def __init__(self, name, age):
        self.__name = name
        self.age = age
obj = Foo("ivan", 123)

# 公有成员
print(obj.age)
# 私有成员
print(obj.__name)
```

![image-20220401180731546](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220401180731546.png)

因为私有成员不能被直接调用，所以借助函数来实现

```python
class Foo(object):

    def __init__(self, name, age):
        self.__name = name
        self.age = age
    def get_name(self):
      return self.__name
obj = Foo("ivan", 123)

# 公有成员
print(obj.age)
# 私有成员
v = obj.get_name()
print(v)  
		123
		ivan
```

如果说方法是私有的

```python
class Foo(object):
    def get_age(self):
        print("公有的get_age")

    def __get_data(self):
        print("私有的__get_data方法")
obj = Foo()  
obj.get_age() #公有的get_age
obj.__get_data() 没有返回
```

同样需要借助函数来实现

```python
class Foo(object):
    def get_age(self):
        print("公有的get_age")
    def __get_data(self):
        print("私有的__get_data方法")
    def proxy(self):
        print("公有的proxy")
        self.__get_data()
obj = Foo()
obj.get_age()
obj.proxy()
>>>>公有的get_age
    公有的proxy
    私有的__get_data方法
```

```python
class Foo(object):

    @property
    def __name(self):
        print("私有的__get_name")
    @property
    def proxy(self):
        print("公有的proxy")
        self.__name
        return 1
obj = Foo()
v1 = obj.proxy
print('v1 = {}'.format(v1))
>>>	公有的proxy
		私有的__get_data
		v1 = 1
```

`特别提醒：父类中的私有成员，子类无法继承`

```python
class A():

    def __a(self):
        print("私有的A.__a")
    def b(self):
        print("公有的A.b")

class B(A):
    def get_A(self):
        self.__a()
        self.b()

b = B()
f =b.get_A()
```

![image-20220401182406926](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220401182406926.png)

```python
class A():

    def __a(self):
        print("私有的A.__a")
    def b(self):
        print("公有的A.b")
        self.__a()

class B(A):
    def get_A(self):
        self.b()

b = B()
f =b.get_A()
>>> 公有的A.b
		私有的A.__a
```

### 对象嵌套

在基于面向对象进行编程时，对象之间可以存在各种各样的关系，例如：组合、关联、依赖等（Java中的称呼），用大白话来说就是各种嵌套

![image-20220402165723099](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220402165723099.png)

### 特殊成员

`__init__`：初始化

```python
class Student(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age
s1 = Student("ivanlee", 19)
```

`__new__`：构造方法

```python
class Student(object):
    def __init__(self, name, age):
        print('第二步：初始化对象，在空对象中创建数据')
        self.name = name
        self.age = age
    def __new__(cls, *arggs, **kwargs):
      print("第一步：先创建一个空对象并返回")
      return object.__new__(cls)
s1 = Student("ivanlee", 19)
>>>>第一步：先创建一个空对象并返回
    第二步：初始化对象，在空对象中创建数据
```

`__call__`：所有的函数都是可调用对象。一个类实例也可以变成一个可调用对象，只需要实现一个特殊方法__call__ ，我们把 类变成一个可调用对象

```python
class Foo(object):
    def __call__(self, *args, **kwargs):
        print("执行call方法")
obj = Foo()
obj() >>> 执行call方法
```

`__dict__`：把实例对象以字典形式的返回

```python
class A(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

a = A('ivan',20)
print(a.__dict__)
>>> {'name': 'ivan', 'age': 20}
```

`__getitem__`: 如果在类中定义了`__getitem__()`方法，那么他的实例对象（假设为P）就可以这样`P[key]`取值。当实例对象做`P[key]`运算时，就会调用类中的`__getitem__()`方法。

`__setitem__(self,key,value)`: 这个方法应该以与键相关联的方式存储值，以便之后能够使用`__setitem__`来获取。当然，这个对象可变时才需要实现这个方法。

`__delitem__(self,key)`：这个方法在对对象的组成部分使用`__del__`语句的时候被调用，应删除与key相关联的值。同样，仅当对象可变的时候，才需要实现这个方法。

![image-20220402173756476](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220402173756476.png)

`__enter__`+`__exit__`：在python中实现了__enter__和__exit__方法，即支持上下文管理器协议。上下文管理器就是支持上下文管理器协议的对象，它是为了with而生。当with语句在开始运行时，会在上下文管理器对象上调用 __enter__ 方法。with语句运行结束后，会在上下文管理器对象上调用 __exit__ 方法

```python
class A():
    def __init__(self,file):
        self.file = file

    def __enter__(self):
        self.f = open(self.file, 'r')
        return self.f
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.f.close()
_file = A('ivan.txt')
with _file as t:
    print('test result: {}'.format(t))
```

#### 上下文管理的语法

`__add__`等加减乘除

```python
class A():
    def __init__(self,a):
        self.a = a

    def __add__(self, other):
        return '{}-{}'.format(self.a,other.a)

m = A('ivan')
n = A('lee')
f = m.__add__(n)
print(f) >>> ivan-lee
```

`__iter__`迭代器:

```python
迭代器类型的定义：
    1.当类中定义了 __iter__ 和 __next__ 两个方法。
    2.__iter__ 方法需要返回对象本身，即：self
    3. __next__ 方法，返回下一个数据，如果没有数据了，则需要抛出一个StopIteration的异常。
```

```python
# 创建 迭代器类型 ：
	class IT(object):
        def __init__(self):
            self.counter = 0

        def __iter__(self):
            return self

        def __next__(self):
            self.counter += 1
            if self.counter == 3:
                raise StopIteration()
            return self.counter

# 根据类实例化创建一个迭代器对象：
    obj1 = IT()
    
    # v1 = obj1.__next__()
    # v2 = obj1.__next__()
    # v3 = obj1.__next__() # 抛出异常
    
    v1 = next(obj1) # obj1.__next__()
    print(v1) 1

    v2 = next(obj1)
    print(v2) 2

    v3 = next(obj1)
    print(v3) 3


    obj2 = IT()
    for item in obj2:  # 首先会执行迭代器对象的__iter__方法并获取返回值，一直去反复的执行 next(对象) 
        print(item) 1 2 3
        
迭代器对象支持通过next取值，如果取值结束则自动抛出StopIteration。
for循环内部在循环时，先执行__iter__方法，获取一个迭代器对象，然后不断执行的next取值（有异常StopIteration则终止循环）。
```

`生成器`: 如果按照迭代器的规定来看，其实生成器类也是一种特殊的迭代器类（生成器也是一个中特殊的迭代器）

```python
创建生成器对象（内部是根据生成器类generator创建的对象），生成器类的内部也声明了：__iter__、__next__ 方法。
    obj1 = func()
    
    v1 = next(obj1)
    print(v1)

    v2 = next(obj1)
    print(v2)

    v3 = next(obj1)
    print(v3)


    obj2 = func()
    for item in obj2:
        print(item)
```

`可迭代对象`：可以使用内置`__iter__`方法的都叫做可迭代对象

　　基本数据类型中的可迭代对象有　`str list tuple dict set`

　　文件对象本身就是迭代器对象（所以文件对象执行内置的`__iter__`之后还是本身，没有任何变化）

```python
 如果一个类中有__iter__方法且返回一个迭代器对象 ；则我们称以这个类创建的对象为可迭代对象。
class Foo(object):
    
    def __iter__(self):
        return 迭代器对象(生成器对象)
    
obj = Foo() # obj是 可迭代对象。

# 可迭代对象是可以使用for来进行循环，在循环的内部其实是先执行 __iter__ 方法，获取其迭代器对象，然后再在内部执行这个迭代器对象的next功能，逐步取值。
for item in obj:
    pass
```

```python
class Iter():    # 迭代器
    def __init__(self):
        self.count = 0
    def __iter__(self):
        return self
    def __next__(self):
        self.count += 1
        if self.count > 3 :
            raise StopIteration
        return self.count
class Foo():
    def __iter__(self):
        return Iter() # 返回一个迭代器对象

it = Foo()  # it就是可迭代对象
for item in it: #循环可迭代对象时，内部先执行obj.__iter__并获取迭代器对象；不断地执行迭代器对象的next方法
    print(item)
```

基于可迭代对象+迭代器实现range功能

```python
class IterRange():
    def __init__(self,num):
        self.count = -1
        self.num = num
    def __iter__(self):
        return self
    def __next__(self):
        self.count += 1
        if self.count == self.num:
            raise StopIteration
        return self.count
class Xrange():
    def __init__(self,max_num):
        self.max_num = max_num
    def __iter__(self):
        return IterRange(self.max_num)

obj = Xrange(10)
for i in obj:
    print(i)
```

常见的迭代类型：

```python
from collections.abc import Iterator,Iterable
v = list([11,22,33,44])
print(isinstance(v,Iterator)) False
print(isinstance(v,Iterable)) True
v1 = v.__iter__()
print(isinstance(v1,Iterator)) True
print(isinstance(v1,Iterable)) True
```

判断依据是是否有`__iter__`且返回一个迭代器对象

## 作业

1. 列举面向对象的成员并简述他们的特点。

   ```python
   变量
       - 实例变量，属于对象。每个对象中中都封装各自的值。只能通过的对象来进行调用。
       - 类变量，属于类。每个类中各自保存的数据。可以通过对象和类来进行读取。
   - 方法
       - 绑定方法，默认有一个self参数，由对象进行调用（此时self就等于调用方法的这个对象）【对象&类均可调用】
       - 类方法，默认有一个cls参数，用类或对象都可以调用（此时cls就等于调用方法的这个类）【对象&类均可调用】
       - 静态方法，无默认参数，用类和对象都可以调用。【对象&类均可调用】
   - 属性
       基于方法+property装饰器实现可以实现，可以实现
           obj.属性名
           obj.属性名 = 123
           del obj.属性名
       语法和方法的对应关系。
   ```

2. `@staticmethod` 和 `@classmethod`的作用是什么？

3. 面向对象中如何让成员变为私有。

4. `__new__`方法的作用？

5. 简述你理解的：迭代器、生成器、可迭代对象。

   - > 迭代器：含有`__iter__`和`__next__`方法，`__iter__`返回类本身，`__next__`可以获取数据（终止是抛出StopIteration异常。可以被for循环。
     >
     > 生成器：在定义时是函数中重要包含yield就是生成器函数，执行函数获得生成器对象（一种特殊的迭代器）；可以通过next取值 & 也可以通过for循环取值
     >
     > 可迭代对象：含有 `__iter__`方法，且返回一个迭代器对象。可以被for循环

6. 看代码写结果

   ```python
   class Foo(object):
       a1 = 1
       
       def __init__(self,num):
           self.num = num
           
       def show_data(self):
           print(self.num+self.a1)
       
   obj1 = Foo(666)
   obj2 = Foo(999)
   
   print(obj1.num) #666
   print(obj1.a1) # 1
   
   obj1.num = 18
   obj1.a1 = 99
   
   print(obj1.num) #18
   print(obj1.a1)  #19
   
   print(obj2.a1)  #1
   print(obj2.num) #999
   print(Foo.a1)   #1
   print(obj1.a1)  #99
   ```

7. 看代码写结果，注意返回值。

   ```python
   class Foo(object):
       
       def f1(self):
           return 999
       
       def f2(self):
           v = self.f1()
           print('f2')
           return v
       
       def f3(self):
           print('f3')
           return self.f2()
       
       def run(self):
           result = self.f3()
           print(result)
   
   obj = Foo()
   v1 = obj.run() # f3 -> f2 -> 999 -> none
   print(v1)
   ```

8. 看代码写结果【如果有错误，则标注错误即可，并且假设程序报错可以继续执行】

   ```python
   class Foo(object):
       
       def f1(self):
           print('f1')
   
       @staticmethod
       def f2():
           print('f2')
           
   obj = Foo()
   obj.f1() f1
   obj.f2() f2
   
   Foo.f1() 报错:没有实例对象
   Foo.f2() f2
   ```

9. 看代码写结果【如果有错误，则标注错误即可，并且假设程序报错可以继续执行】

   ```python
   class Foo(object):
       
       def f1(self):
           print('f1')
           self.f2()
           self.f3()
   
       @classmethod
       def f2(cls):
             print('f2')
   
       @staticmethod
       def f3():
             print('f3')
   
   obj = Foo()
   obj.f1() # f1 -> f2 -> f3
   ```

10. 看代码写结果【如果有错误，则标注错误即可，并且假设程序报错可以继续执行】

    ```python
    class Base(object):
        @classmethod
        def f2(cls):
              print('f2')
    
        @staticmethod
        def f3():
              print('f3')
    
    class Foo(Base):
        def f1(self):
            print('f1')
            self.f2()
            self.f3()
    
    obj = Foo() 
    obj.f1()   # f1 f2 f3
    ```

11. 看代码写结果【如果有错误，则标注错误即可，并且假设程序报错可以继续执行】

    ```python
    class Foo(object):
        a1 = 1
        __a2 = 2
        
        def __init__(self,num):
            self.num = num
            self.__salary = 1000
            
         def show_data(self):
             print(self.num+self.a1)
        
    obj = Foo(666)
    
    print(obj.num) #666
    print(obj.a1)  # 1
    print(obj.__salary) #error
    print(obj.__a2) # error
    print(Foo.a1) #1
    print(Foo.__a2) # error
    obj.show_data() #667
    ```

12. 看代码写结果

    ```python
    class Foo(object):
    
        def __init__(self, age):
            self.age = age
    
        def display(self):
            print(self.age)
    
    
    data_list = [Foo(8), Foo(9)]
    
    for item in data_list:
        print(item.age, item.display()) 
    ```

13. 看代码写结果

    ```python
    class Base(object):
        def __init__(self, a1):
            self.a1 = a1
    
        def f2(self, arg):
            print(self.a1, arg)
    
    
    class Foo(Base):
        def f2(self, arg):
            print('666')
    
    
    obj_list = [Base(1), Foo(2), Foo(3)]
    #           1,1       666      666
    for item in obj_list:
        item.f2(1)
    ```

14. 看代码写结果

    ```python
    class Foo(object):
        def __init__(self, num):
            self.num = num
            
    v1 = [Foo for i in range(10)]
    v2 = [Foo(5) for i in range(10)]
    v3 = [Foo(i) for i in range(10)]
    
    print(v1)  # none
    print(v2)  # 
    print(v3)
    ```

    ![image-20220403141900364](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220403141900364.png)

15. 看代码写结果

    ```python
    class StarkConfig(object):
    
        def __init__(self, num):
            self.num = num
    
        def changelist(self, request):
            print(self.num, request)
    
    
    config_obj_list = [ StarkConfig(1),  StarkConfig(2),  StarkConfig(3) ]
    for item in config_obj_list:
        print(item.num)
    ```

16. 看代码写结果

    ```python
    class StarkConfig(object):
    
        def __init__(self, num):
            self.num = num
    
        def changelist(self, request):
            print(self.num, request)
    
    
    config_obj_list = [StarkConfig(1), StarkConfig(2), StarkConfig(3)]
    for item in config_obj_list:
        item.changelist(666)
        1,666
        2,666
        3,666
    ```

17. 看代码写结果

    ```python
    class StarkConfig(object):
    
        def __init__(self, num):
            self.num = num
    
        def changelist(self, request):
            print(self.num, request)
    
        def run(self):
            self.changelist(999)
    
    
    class RoleConfig(StarkConfig):
    
        def changelist(self, request):
            print(666, self.num)
    
    
    class AdminSite(object):
        def __init__(self):
            self._registry = {}
    
        def register(self, k, v):
            self._registry[k] = v
    
    
    site = AdminSite()
    
    site.register('武沛齐', StarkConfig(19))
    site.register('root', StarkConfig(20))
    site.register("admin", RoleConfig(33))
    
    print(len(site._registry))#3
    
    for k, row in site._registry.items():
        row.changelist(5)
        19,5
        20,5
        666,33
    
    ```

18. 看代码写结果（如有报错，请标注报错位置）

    ```python
    class StarkConfig(object):
        def __init__(self, num):
            self.num = num
        def run(self):
            self()
        def __call__(self, *args, **kwargs):
            print(self.num)
            
    class RoleConfig(StarkConfig):
        def __call__(self, *args, **kwargs):
            print(345)
        def __getitem__(self, item):
            return self.num[item]
        
    v1 = RoleConfig('alex')
    v2 = StarkConfig("wupeiqi")
    
    print(v1[1])
    print(v2[2])
    ```

19. 补全代码

    ```python
    class Context:
    	pass
    
    
    with Context() as ctx:
        ctx.do_something()
    ```

20. 看代码写结果

    ```python
    class Department(object):
        def __init__(self,title):
            self.title = title
    
    class Person(object):
        def __init__(self,name,age,depart):
            self.name = name
            self.age = age 
            self.depart = depart
    	
        def message(self):
            msg = "我是%s,年龄%s,属于%s" %(self.name,self.age,self.depart.title)
            print(msg)
        
        
    d1 = Department('人事部')
    d2 = Department('销售部')
    
    p1 = Person('武沛齐',18,d1)
    p2 = Person('alex',18,d1)
    
    p1.message()
    p2.message()
    ```

21. 分析代码关系，并写出正确的输出结果。

    ```python
    class Node(object):
        def __init__(self, title):
            self.title = title
            self.children = []
    
        def add(self, node):
            self.children.append(node)
    
        def __getitem__(self, item):
            return self.children[item]
    
    
    root = Node("中国")
    
    root.add(Node("河南省"))
    root.add(Node("河北省"))
    
    print(root.title) #中国
    print(root[0])
    print(root[0].title)
    print(root[1])
    print(root[1].title)
    ```

    

22. 分析代码关系，并写出正确的输出结果。

    ```python
    class Node(object):
        def __init__(self, title):
            self.title = title
            self.children = []
    
        def add(self, node):
            self.children.append(node)
    
        def __getitem__(self, item):
            return self.children[item]
    
    
    root = Node("中国")
    
    root.add(Node("河南省"))
    root.add(Node("河北省"))
    root.add(Node("陕西省"))
    root.add(Node("山东省"))
    
    root[1].add(Node("石家庄"))
    root[1].add(Node("保定"))
    root[1].add(Node("廊坊"))
    
    root[3].add(Node("潍坊"))
    root[3].add(Node("烟台"))
    root[3].add(Node("威海"))
    
    root[1][1].add(Node("雄安"))
    root[1][1].add(Node("望都"))
    
    print(root.title)
    print(root[0].title)
    print(root[1].title)
    print(root[1][0].title)
    print(root[1][2].title)
    print(root[1][1][0].title)
    ```

    

----------

## 继承补充

调用类中的成员时，遵循：

- 优先在自己所在类中找，没有的话则去父类中找。
- 如果类存在多继承（多个父类），则先找左边再找右边。

#### 继承顺位的算法

- `mro函数`：通过调用`mro`函数来获取继承的顺序

  例1 ：

  ![image-20220404111555920](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220404111555920.png)

  ![image-20220404111832992](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220404111832992.png)

​       `c3`算法：

```python
mro(A) = [A] + merge(mro(B), mro(C),[B,C])
			 = [A] + merge([B,object], [C,D,object], [B,C])
  		 = [A,B] + merge([object], [C,D,object],[C])
    	 = [A,B,C] + merge([],[D],[])
       = [A,B,C,D]
```

​	

​	例2:	![image-20220404111905471](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220404111905471.png)

![image-20220404112151283](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220404112151283.png)

`c3`：

```python
mro(A) = [A] + merge(mro(B), mro(C),[B,C])
			 = [A] + merge([B,D,object],[C,object], [B,C])
  		 = [A,B] + merge([D,object], [C,object],[C])
    	 = [A,B,D] + merge([],[C,object],[C])
       = [A,B,D,C]
```



例3:

![image-20220404112305227](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220404112305227.png)

![image-20220404112616136](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220404112616136.png)

`c3`:

```python
mro(A) = [A] + merge(mro(B), mro(C),[B,C])
			 = [A] + merge([B,D,object],[C,D,object], [B,C])
  		 = [A] + merge([B,C,D]) 
    	 = [A,B,C,D]
```

`obj.mro()`和`obj.__mro__`:`mro()`返回列表`__mro__`返回元组

![image-20220404112823432](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220404112823432.png)

例4:

![image-20220404113113871](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220404113113871.png)

```mysql
(<class '__main__.A'>, <class '__main__.B'>, <class '__main__.D'>, <class '__main__.G'>, 
 <class '__main__.H'>, <class '__main__.K'>, <class '__main__.C'>, <class '__main__.E'>, 
 <class '__main__.F'>, <class '__main__.M'>, <class '__main__.N'>, <class '__main__.P'>, <class 'object'>)
```

**从左到右，深度优先，大小钻石，留住顶端**

### 内置函数补充

- `callable` 函数用于检查一个对象是否是可调用的。如果返回 True，object 仍然可能调用失败；但如果返回 False，调用对象 object 绝对不会成功。对于函数、方法、`lambda` 函式、 类以及实现了 `__call__ `方法的类实例, 它都返回 True。 

  - 对于函数：

    ```python
    def add_(a,b):
        return a+b
    
    x = callable(add_)
    print(x) >>> True
    ```

  - 对于类：

    ```python
    class A():
        def _return(self):
            return 'xxxx'
    x = callable(A)
    print(x) True
    
    a = A()
    x = callable(a) #A中没有__call__函数，无法调用
    print(x) False
    
    class B():
        def __call__(self, *args, **kwargs):
            return 1
    b = B()
    x = callable(b)
    print(x) True
    ```

  - `super`函数是用于调用父类(超类)的一个方法。是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。

    ```python
    class A():
        def message(self, a = 0):
            print('A.message',a)
    class B(A):
        def message(self):
            print('B.message')
            super().message()
    
    b = B()
    b.message()
    >>> B.message
    		A.message 0
    ```

    ![image-20220404125145073](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220404125145073.png)

    如果B类中没有message函数，那么就会报错

    ![image-20220404125258214](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220404125258214.png)

    ![image-20220404125444065](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220404125444065.png)

    - `super`的应用场景【对list进行扩展】

      ```python
      class List_(list):
          def _append(self, *args, **kwargs):
              super().append(*args, **kwargs)
              return "添加成功"
      
      l = List_()
      res = l._append('{ivan:lee}')
      print(l,res)
      >>> ['{ivan:lee}'] 添加成功
      ```

  - `type` 获取一个对象的类型

    ```python
    a = 'ivan'
    print(type(a))
    b = 1234
    print(type(b))
    
    class C:
        pass
    c = C()
    print(type(c))
    >>>
    <class 'str'>
    <class 'int'>
    <class '__main__.C'>
    ```

  - `isinstance`判断对象是否是某个类或其子类的实例

    ```python
    a = 'ivan'
    print(isinstance(a,str))
    b = 1234
    print(isinstance(b,int))
    
    class C:
        pass
    c = C()
    print(isinstance(c,C))
    全部都是True
    ```

    ```python
    class Top(object):
        pass
    class Base(Top):
        pass
    class Foo(Base):
        pass
    
    v1 = Foo()
    print( isinstance(v1, Foo) )   # True，对象v1是Foo类的实例
    print( isinstance(v1, Base) )  # True，对象v1的Base子类的实例。
    print( isinstance(v1, Top) )   # True，对象v1的Top子类的实例
    ```

  - `issubclass`判断是否是子孙类

    ```python
    class Top(object):
        pass
    class Base(Top):
        pass
    class Foo(Base):
        pass
    
    print( issubclass(Foo, Foo) )    True
    print( issubclass(Foo, Base) )   True
    print( issubclass(Foo, Top) )    True
    ```

	### 异常处理

基本格式：

```python
try:
    # 逻辑代码
except Exception as e:
    # try中的代码如果有异常，则此代码块中的代码会执行。
```

```python
try:
    # 逻辑代码
except Exception as e:
    # try中的代码如果有异常，则此代码块中的代码会执行。
finally:
    # try中的代码无论是否报错，finally中的代码都会执行，一般用于释放资源。
```

异常细分的格式：

```python
try:
    # 逻辑代码
    pass

except KeyError as e:
    # 小兵，只捕获try代码中发现了键不存在的异常，例如：去字典 info_dict["n1"] 中获取数据时，键不存在。
    print("KeyError")

except ValueError as e:
    # 小兵，只捕获try代码中发现了值相关错误，例如：把字符串转整型 int("无诶器")
    print("ValueError")

except Exception as e:
    # 王者，处理上面except捕获不了的错误（可以捕获所有的错误）。
    print("Exception")
```

Python中内置了很多细分的错误，供你选择。

```python
常见异常：
"""
AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x
IOError 输入/输出异常；基本上是无法打开文件
ImportError 无法引入模块或包；基本上是路径问题或名称错误
IndentationError 语法错误（的子类） ；代码没有正确对齐
IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问n x[5]
KeyError 试图访问字典里不存在的键 inf['xx']
KeyboardInterrupt Ctrl+C被按下
NameError 使用一个还未被赋予对象的变量
SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）
TypeError 传入对象类型与要求的不符合
UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，
导致你以为正在访问它
ValueError 传入一个调用者不期望的值，即使值的类型是正确的
"""
更多异常：
"""
ArithmeticError
AssertionError
AttributeError
BaseException
BufferError
BytesWarning
DeprecationWarning
EnvironmentError
EOFError
Exception
FloatingPointError
FutureWarning
GeneratorExit
ImportError
ImportWarning
IndentationError
IndexError
IOError
KeyboardInterrupt
KeyError
LookupError
MemoryError
NameError
NotImplementedError
OSError
OverflowError
PendingDeprecationWarning
ReferenceError
RuntimeError
RuntimeWarning
StandardError
StopIteration
SyntaxError
SyntaxWarning
SystemError
SystemExit
TabError
TypeError
UnboundLocalError
UnicodeDecodeError
UnicodeEncodeError
UnicodeError
UnicodeTranslateError
UnicodeWarning
UserWarning
ValueError
Warning
ZeroDivisionError
"""
```

### 反射

反射，提供了一种更加灵活的方式让你可以实现去 对象 中操作成员（以字符串的形式去 `对象` 中进行成员的操作）。

```python
class User():
    def __init__(self,name,age):
        self.name = name
        self.age = age
    def show(self):
        message = '{}-{}'.format(self.name,self.age)
        print(message)

user = User('ivanlee','717')
s = getattr(user,'name')
print(s)
fun = getattr(user,'show')
fun()
setattr(user,'name','ivan')
print(getattr(user,'name'))
>>> ivanlee
>>> ivanlee-717
>>> ivan
```

#### 四个内置函数

- `getattr` 获取一个对象属性值

- `setattr` 用于设置属性值，该属性不一定是存在的

- `hasattr` 函数用于判断对象是否包含对应的属性

- `delattr` 函数用于删除属性。`delattr(x, 'foobar')` 相等于` del x.foobar`

  ```python
  
  class Coordinate:
      x = 10
      y = -5
      z = 0
  
  
  point1 = Coordinate()
  _x = getattr(point1,'x')
  print(_x) 10
  setattr(point1,'y',5)
  print(hasattr(point1,'m')) False
  delattr(Coordinate,'z')
  print(point1.x,point1.y) 10,5
  ```

#### `import_module+模块`

动态导入对象`importlib.import_module()`

```python
from importlib import import_module
m = import_module("random")
v1 = m.randint(1,100)
print(v1)
```

---

# 网络编程

### 交换机

#### 二层交换机和三层交换机的区别：

二层交换机指的是交换功能，工作在数据链路层，在本局域网内根据MAc地址进行转发

三层交换机指的是路由功能，工作在网络层，具有路由功能，可以跨局域网根据路由信息进行数据传输

### 网络名词

#### 子网掩码和`ip`地址

电脑要实现网络通信，必须要有一个合法的ip地址，而`ip地址= 网络地址（网络号） + 主机地址（主机号）`

子网掩码就是用`1`表示掩盖，用`0`表示暴露，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，需要和ip地址一起使用，它的作用就是把某个ip地址划分为网络地址和主机地址两部分。通过子网掩码，可以看出多少位是网络号，多少位是主机号。

- 问题1：如何确定网络地址和主机地址呢？

  ```
  通过子网掩码就可以确定IP的网络地址和主机地址。
  
  示例1：
      	IP：192.168.1.199      11000000.10101000.00000001.11000111
  	子网掩码：255.255.255.0     11111111.11111111.11111111.00000000
  此时，网络地址就是前24位 + 主机地址是后8位。你可能见过有些IP这样写 192.168.1.199/24，意思也是前24位是网络地址。
  
  
  示例2：
      	IP：192.168.99.254     11000000.10101000.01100011.11111110
  	子网掩码：255.255.240.0     11111111.11111111.11111100.00000000
  此时，网络地址就是前22位 + 主机地址是后10位。你可能见过有些IP这样写 192.168.99.254/22，意思也是前22位是网络地址。
  ```

- 问题2：划分 网络地址 + 主机地址 的意义是什么？

  ```
  网络地址相同的IP，也称为属于同一个网段。
  在局域网内只有同一个网段的IP才能相互通信，不同网段IP想要通信需要借助路由的转发才能通信。
  
  当了解子网掩码之后，其实就可以确定某个网段可以容纳的主机个数，例如：
  【IP: 192.168.10.2  掩码：255.255.255.0】 和 【192.168.10.251 掩码：255.255.255.0】 数据同一个网段。
  
  	示例网段的主机范围：11000000.10101000.00001010. 00000001  ~  11000000.10101000.00001010.  11111110
  	                 --------------------------              --------------------------
  	                          网络地址                                   网络地址
  				           192.168.10.1                 ~           192.168.10.254
                             
  【IP: 192.168.8.1  掩码：255.255.240.0】 和 【192.168.11.254 掩码：255.255.240.0】 数据同一个网段。
  	子网掩码：255.255.240.0
  	示例网段的主机范围：11000000.10101000.000010 00.00000001  ~  11000000.10101000.000010 11.11111110
  	                 11111111.11111111.111111 00.00000000
  	                 ------------------------                 ------------------------
  	                          网络地址                                   网络地址
  				           192.168.8.1                 ~           192.168.11.254
  				           
  【IP: 192.168.96.1  掩码：255.255.240.0】 和 【192.168.99.254  掩码：255.255.240.0】 数据同一个网段。
  	示例网段的主机范围：11000000.10101000.011000 00.00000001  ~  11000000.10101000.011000 11.11111110
  	         
  	                 ------------------------                 ------------------------
  	                          网络地址                                   网络地址
  				           192.168.96.1                 ~           192.168.99.254    
  ```

  以后如果想开发一个网站供全球的用户访问，那你就需要做以下几件事：

  - 拉专线，申请固定公网IP
  - 买一台服务器（就是性能好的电脑）
  - 公网IP绑定至此服务器
  - 将写好的代码放在服务器上并运行起来

  ### python网络编程

  python中内置了socket模块，可以实现网络传输，通过层`c/s`架构进行连接

  `server.py`

  ```python
  import socket
  
  sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #监听本机的端口
  # 参数socket.AF_INET: 地址簇，默认ipv4
  # 参数socket.SOCK_STREAM: 默认流式socket，用tcp协议
  sk.bind('ip_address','port')
  sk.listen(5) #支持排队等待
  
  while True:
      conn,addr = sk.accept() #等待客户来连接，否则不运行后面
      recv_data = conn.recv(1024) # 接受客户的信息，1024表示最大接受字节数
      print(recv_data.decode('utf8'))
      conn.sendall('something'.encode('utf8')) #给客户回消息
      conn.close() #当前客户连接关闭
  
  sk.close() #程序停止
  ```

  `client.py`

  ```python
  import socket
  
  client = socket.socket()
  client.connect('ip_address','port')
  client.sendall('something'.encode('utf8'))
  
  reply = client.recv(1024)
  
  print(reply.decode('utf8'))
  client.close()
  ```


例子：上传文件

`server.py`

```python
import socket

sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sk.bind(('127.0.0.1',8001))
sk.listen(5)

conn, addr = sk.accept()
data = conn.recv(1024)
file_total_size = int(data.decode('utf8'))
''' 接受文件内容'''
file_obj = open ('xxx.png',mode = 'wb')
recv_size = 0

while recv_size < file_total_size:
  data = conn.recv(1024)
  recv_size += len(data)
  file_obj.write(data)
  file_obj.flush()
  
conn.close()
sk.close()
```

`client.py`

```python
client = socket.socket()
client.connect(('127.0.0.1', 8001))

file_path = input("请输入要上传的文件：")

# 先发送文件大小
file_size = os.stat(file_path).st_size
client.sendall(str(file_size).encode('utf-8'))

print("准备...")
time.sleep(2)
print("开始上传..")
file_object = open(file_path, mode='rb')
read_size = 0
while True:
    chunk = file_object.read(1024) # 每次读取1024字节
    client.sendall(chunk)
    read_size += len(chunk)
    if read_size == file_size:
        break

client.close()
```

-----

## 网络七层模型

假设，你在浏览器上输入了一些关键字，内部通过DNS找到对应的IP后，再发送数据时内部会做如下的事：

- 应用层：规定数据的格式。

  ```python
  "GET /s?wd=你好 HTTP/1.1\r\nHost:www.baidu.com\r\n\r\n"
  ```

- 表示层：对应用层数据的编码、压缩（解压缩）、分块、加密（解密）等任务。

  ```python
  "GET /s?wd=你好 HTTP/1.1\r\nHost:www.baidu.com\r\n\r\n你好".encode('utf-8')
  ```

- 会话层：负责与目标建立、中断连接。

  ```
  在发送数据之前，需要会先发送 “连接” 的请求，与远程建立连接后，再发送数据。当然，发送完毕之后，也涉及中断连接的操作。
  ```

- 传输层：建立端口到端口的通信，其实就确定双方的端口信息。

  ```python
  数据："GET /s?wd=你好 HTTP/1.1\r\nHost:www.baidu.com\r\n\r\n你好".encode('utf-8')
  端口：
  	- 目标：80
  	- 本地：6784
  ```

- 网络层：标记目标IP信息（IP协议层）

  ```python
  数据："GET /s?wd=你好 HTTP/1.1\r\nHost:www.baidu.com\r\n\r\n你好".encode('utf-8')
  端口：
  	- 目标：80
  	- 本地：6784
  IP：
  	- 目标IP：110.242.68.3（百度）
  	- 本地IP：192.168.10.1
  ```

- 数据链路层：对数据进行分组并设置源和目标mac地址

  ```python
  数据："POST /s?wd=你好 HTTP/1.1\r\nHost:www.baidu.com\r\n\r\n你好".encode('utf-8')
  端口：
  	- 目标：80
  	- 本地：6784
  IP：
  	- 目标IP：110.242.68.3（百度）
  	- 本地IP：192.168.10.1
  MAC：
  	- 目标MAC：FF-FF-FF-FF-FF-FF 
  	- 本机MAC：11-9d-d8-1a-dd-cd
  ```

- 物理层：将二进制数据在物理媒体上传输。

  ```
  通过网线将二进制数据发送出去
  ```



![image-20210209113923860](/Users/ivanlee/Desktop/前3模块/day21 网络编程（下）/笔记/assets/image-20210209113923860.png)

每一层各司其职，最终保证数据呈现在到用户手中。

## UDP和TCP协议

协议，其实就是规定 连接、收发数据的一些规定。

在OSI的 传输层 除了定义端口信息以外，常见的还可以指定UDP或TCP的协议，协议不同连接和传输数据的细节也会不同。

- `UDP（User Data Protocol）`用户数据报协议， 是⼀个⽆连接的简单的⾯向数据报的传输层协议。 UDP不提供可靠性， 它只是把应⽤程序传给IP层的数据报发送出去， 但是并不能保证它们能到达⽬的地。 由于UDP在传输数据报前不⽤在客户和服务器之间建⽴⼀个连接， 且没有超时重发等机制， 故⽽传输速度很快。

  ```
  常见的有：语音通话、视频通话、实时游戏画面 等。
  ```

- `TCP（Transmission Control Protocol`传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接，然后再进行收发数据。

  ```
  常见有：网站、手机APP数据获取等。
  ```

UDP示例如下：

- 服务端

  ```python
  import socket
  
  server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  server.bind(('127.0.0.1', 8002))
  
  while True:
      data, (host, port) = server.recvfrom(1024) # 阻塞
      print(data, host, port)
      server.sendto("好的".encode('utf-8'), (host, port))
  ```

- 客户端

  ```python
  import socket
  
  client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  while True:
      text = input("请输入要发送的内容：")
      if text.upper() == 'Q':
          break
      client.sendto(text.encode('utf-8'), ('127.0.0.1', 8002))
      data, (host, port) = client.recvfrom(1024)
      print(data.decode('utf-8'))
  
  client.close()
  ```

TCP示例如下：

- 服务端

  ```python
  import socket
  
  # 1.监听本机的IP和端口
  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  sock.bind(('127.0.0.1', 8001))
  sock.listen(5)
  
  while True:
      # 2.等待，有人来连接（阻塞）
      conn, addr = sock.accept()
  
      # 3.等待，连接者发送消息（阻塞）
      client_data = conn.recv(1024)
      print(client_data)
  
      # 4.给连接者回复消息
      conn.sendall(b"hello world")
  
      # 5.关闭连接
      conn.close()
  
  # 6.停止服务端程序
  sock.close()
  ```

- 客户端

  ```python
  import socket
  
  # 1. 向指定IP发送连接请求
  client = socket.socket()
  client.connect(('127.0.0.1', 8001))
  
  # 2. 连接成功之后，发送消息
  client.sendall(b'hello')
  
  # 3. 等待，消息的回复（阻塞）
  reply = client.recv(1024)
  print(reply)
  
  # 4. 关闭连接
  client.close()
  ```

### 三握手和四握手

```apl
  0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

网络中的双方想要基于TCP连接进行通信，必须要经过：

- 创建连接，客户端和服务端要进行三次握手。

  ```python
  # 服务端
  import socket
  
  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  sock.bind(('127.0.0.1', 8001))
  sock.listen(5)
  
  while True:
      conn, addr = sock.accept() # 等待客户端连接
      ...
  ```

  ```python
  # 客户端
  import socket
  client = socket.socket()
  client.connect(('127.0.0.1',8001))
  ```

```python
    客户端                                                服务端

  1.  SYN-SENT    --> <seq=100><CTL=SYN>               --> SYN-RECEIVED

  2.  ESTABLISHED <-- <seq=300><ack=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

  3.  ESTABLISHED --> <seq=101><ack=301><CTL=ACK>       --> ESTABLISHED
```

- 关闭连接，客户端和服务端要进行4次挥手。

  ```python
  import socket
  
  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  sock.bind(('127.0.0.1', 8001))
  sock.listen(5)
  while True:
      conn, addr = sock.accept()
  	...
      conn.close() # 关闭连接
  sock.close()
  ```

  ```python
  import socket
  
  client = socket.socket()
  client.connect(('127.0.0.1', 8001))
  ...
  client.close() # 关闭连接
  ```

  ```python
         TCP A                                                TCP B
  
    1.  FIN-WAIT-1  --> <seq=100><ack=300><CTL=FIN,ACK>  --> CLOSE-WAIT
  
    2.  FIN-WAIT-2  <-- <seq=300><ack=101><CTL=ACK>      <-- CLOSE-WAIT
  
    3.  TIME-WAIT   <-- <seq=300><ack=101><CTL=FIN,ACK>  <-- LAST-ACK
  
    4.  TIME-WAIT   --> <seq=101><ack=301><CTL=ACK>      --> CLOSED
  ```

### 粘包现象

只有`tcp`才会发生粘包，`udp`不会

两台电脑在进行收发数据时，其实不是直接将数据传输给对方。

- 对于发送者，执行 `sendall/send` 发送消息时，是将数据先发送至自己网卡的 写缓冲区 ，再由缓冲区将数据发送给到对方网卡的读缓冲区。
- 对于接受者，执行 `recv` 接收消息时，是从自己网卡的读缓冲区获取数据。

所以，如果发送者连续快速的发送了2条信息，接收者在读取时会认为这是1条信息，即：**2个数据包粘在了一起**。

`粘包`：多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界，而采用某一估测值大小来进行数据读出，若双方的`size`不一致时就会使指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

先说简单的`接收方`原因,  接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。

```python
# socket客户端（发送者）
import socket

client = socket.socket()
client.connect(('127.0.0.1', 8001))

client.sendall('alex正在吃'.encode('utf-8'))
client.sendall('翔'.encode('utf-8'))

client.close()


# socket服务端（接收者）
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.bind(('127.0.0.1', 8001))
sock.listen(5)
conn, addr = sock.accept()

client_data = conn.recv(1024)
print(client_data.decode('utf-8'))

conn.close()
sock.close()
```

如何解决粘包问题

每次发送消息时，把数据分成头部和数据两部分

- 发送数据时，先发送数据的长度，在发送数据本身，数据的长度可用4字节固定表示
- 接受数据时，先读前四个字节就可以知道数据的长度，再根据长度读数据

#### `struct`模块

1. 按照指定格式将Python数据转换为字符串,该字符串为字节流,如网络传输时,不能传输int,此时先将int转化为字节流,然后再发送;
2. 按照指定格式将字节流转换为Python指定的数据类型;
3. 处理二进制数据,如果用struct来处理文件的话,需要用’wb’,’rb’以二进制(字节流)写,读的方式来处理文本

![image-20220406153748275](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220406153748275.png)

`struct.pack(fmt,v1,v2···)`表示将后面的所有参数用fmt的方式进行封装，然后返回一个包装之后的字符串

`struct.unpack(fmt,v1,v2···)`与之相反

```python
import struct

v1 = struct.pack('i',717)
print(v1)

v2 = struct.unpack('i',v1)
print(v2)
>>>b'\xcd\x02\x00\x00'
>>>(717,)
```

服务器端：

```python
import socket
import struct

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.bind(('127.0.0.1', 8001))
sock.listen(5)
conn, addr = sock.accept()

# 固定读取4字节
header1 = conn.recv(4)
data_length1 = struct.unpack('i', header1)[0] # 数据字节长度 21
has_recv_len = 0
data1 = b""
while True:
    length = data_length1 - has_recv_len
    if length > 1024:
        lth = 1024
    else:
        lth = length
    chunk = conn.recv(lth) # 可能一次收不完，自己可以计算长度再次使用recv收取，指导收完为止。 1024*8 = 8196
    data1 += chunk
    has_recv_len += len(chunk)
    if has_recv_len == data_length1:
        break
print(data1.decode('utf-8'))

#固定读取4字节
header2 = conn.recv(4)
data_length2 = struct.unpack('i', header2)[0] # 数据字节长度
data2 = conn.recv(data_length2) # 长度
print(data2.decode('utf-8'))

conn.close()
sock.close()
```

客户端：

```python
# socket客户端（发送者）
import socket
import struct

client = socket.socket()
client.connect(('127.0.0.1', 8001))

# 第一条数据
data1 = 'alex正在吃'.encode('utf-8')

header1 = struct.pack('i', len(data1))

client.sendall(header1)
client.sendall(data1)

# 第二条数据
data2 = '翔'.encode('utf-8')
header2 = struct.pack('i', len(data2))
client.sendall(header2)
client.sendall(data2)

client.close()
```

###  阻塞和非阻塞模式

![image-20220406160200031](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220406160200031.png)

```python
sock.setblocking(False) # 加上就变为了非阻塞
```

如果代码变成了非阻塞，程序运行时一旦遇到 `accept`、`recv`、`connect` 就会抛出 `BlockingIOError `的异常。

这不是代码编写的有错误，而是原来的IO阻塞变为非阻塞之后，由于没有接收到相关的IO请求抛出的固定错误。

非阻塞的代码一般与IO多路复用结合，可以迸发出更大的作用。

![image-20220406161442473](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220406161442473.png)

### I/O多路复用

`I/O多路复用`：通过一种机制，可以监听多个描述符，一旦某个描述符就绪（读就绪或者写就绪），能够通知程序进行相应的读写操作

I/O多路复用 + 非阻塞，可以实现让TCP的服务端同时处理多个客户端的请求

`select.select()`方法接收并监控3个通信列表， 第一个是所有的输入的data,就是指外部发过来的数据，第2个是监控和接收所有要发出去的`data(outgoing data)`,第3个监控错误信息

`readable, writable, exceptional = select.select(inputs, outputs, inputs)`

第一个参数就是服务器端的socket, 第二个是我们在运行过程中存储的客户端的socket, 第三个存储错误信息.

重点是在返回值, 第一个返回的是可读的 list, 第二个存储的是可写的 list, 第三个存储的是错误信息的 list。

```python
# ################### socket服务端 ###################
import select
import socket

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setblocking(False)  # 加上就变为了非阻塞
server.bind(('127.0.0.1', 8001))
server.listen(5)

inputs = [server, ] # socket对象列表 -> [server, 第一个客户端连接conn ]

while True:
    # 当 参数1 序列中的socket对象发生可读时（accetp和read），则获取发生变化的对象并添加到 r列表中。
    # r = []
    # r = [server,]
    # r = [第一个客户端连接conn,]
    # r = [server,]
    # r = [第一个客户端连接conn，第二个客户端连接conn]
    # r = [第二个客户端连接conn,]
    r, w, e = select.select(inputs, [], [], 0.05)
    for sock in r:
        # server
        if sock == server:
            conn, addr = sock.accept() # 接收新连接。
            print("有新连接")
            # conn.sendall()
            # conn.recv("xx")
            inputs.append(conn)
        else:
            data = sock.recv(1024)
            if data:
                print("收到消息：", data)
            else:
                print("关闭连接")
                inputs.remove(sock)
```

```python
while True:
    rs,ws,es=select.select(inputs,[],[])  #1、select函数阻塞进程，直到inputs中的套接字被触发（在此例中，套接字接收到客户端发来的握手信号，从而变得可读，满足select函数的“可读”条件），rs返回被触发的套接字（服务器套接字）；
                                            # 4、select再次阻塞进程，同时监听服务器套接字和获得的客户端套接字；
    for r in rs:
        if r is s:                          #2、如果是服务器套接字被触发（监听到有客户端连接服务器）
            c, addr = s.accept()
            print('Got connection from', addr)
            inputs.append(c)                #3、inputs加入客户端套接字
        else:                               #5、当客户端发送数据时，客户端套接字被触发，rs返回客户端套接字，然后进行下一步处理。
            try:
                data=r.recv(1024)
                disconnected=not data
            except socket.error:
                disconnected = True
            if disconnected:
                print(r.getpeername(),'disconnected')
                inputs.remove(r)
            else:
                print(data)
```
基于 IO多路复用 + 非阻塞的特性，无论编写socket的服务端和客户端都可以提升性能。其中

- IO多路复用，监测socket对象是否有变化（是否连接成功？是否有数据到来等）。
- 非阻塞，socket的connect、recv过程不再等待。

注意：IO多路复用只能用来监听 IO对象 是否发生变化，常见的有：文件是否可读写、电脑终端设备输入和输出、网络请求（常见）

### **并发编程**

提升代码执行的效率。原来代码执行需要20分钟，学习并发编程后可以加快到1分钟执行完毕。

#### 进程和线程

**进程**是程序的一次执行，每个进程都有自己的地址空间、内存、数据栈及其它记录其运行轨迹的辅助数据。操作系统管理在其上运行的所有进程，并为这些进程公平的分配时间，进程也可以通过fork和spawn操作来完成其它的任务。不过各个进程有自己的内存空间、数据栈等，所以**只能使用进程间通讯，而不能直接共享信息**。`是被计算机cpu调度的最小单元`

**线程**是进程中执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。`是计算机分配资源的最小单元，进程为自己的线程提供资源`

**进程和线程的关系**

- （1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。
- （2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。
- （3）处理机分给线程，即真正在处理机上运行的是线程
- （4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体.

**进程与线程的区别：**

- （1）调度：线程作为`调度和分配`的基本单位，进程作为`拥有资源`的基本单位
- （2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
- （3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.
- （4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。

 通过 **进程** 和 **线程** 都可以将 `串行` 的程序变为`并发`，对于示例来说就是同时计算，减少总共的计算时间。

```python
import os, time,threading
sum_ = 0
start = time.time()
for i in range(10000000):
    sum_ += i
end = time.time()
print(end-start)
----------------------------------------------------------------------------------------------------------
def _add(a,b):
    sum_ = 0
    for i in range(a,b):
start = time.time()
t1 = threading.Thread(target=_add, args=(0,5000000))
t1.start()
t1.join()
t2 = threading.Thread(target=_add, args=(5000000,10000000))
t2.start()
t2.join()
end = time.time()
print(end-start)
>>> 0.9478561878204346
		0.5223159790039062
```

##### 多进程

需要用到`mutilprocessing`模块，语句为`p = multiprocessing.Process(target = , args=())`

```python
import os, time,multiprocessing
def normal_add():
    _sum = 0
    start_time = time.time()
    for i in range(10000000):
        _sum += i
    end_time = time.time()
    print("耗时:", end_time - start_time)
def task(start, end, queue):
    result = 0
    for i in range(start, end):
        result += i
    queue.put(result)
if __name__ == '__main__':
    normal_add()  >>> 耗时: 0.5224120616912842
    queue = multiprocessing.Queue()
    start_time = time.time()
    p1 = multiprocessing.Process(target=task, args=(0, 5000000, queue))
    p1.start()
    p2 = multiprocessing.Process(target=task, args=(5000000, 10000000, queue))
    p2.start()
    v1 = queue.get(block=True) #阻塞
    v2 = queue.get(block=True) #阻塞
    print(v1 + v2)
    end_time = time.time()
    print("耗时:", end_time - start_time) >>>耗时: 0.33182621002197266
```

### GIL锁

*python*全局解释器锁或`GIL`是一种[互斥锁](https://so.csdn.net/so/search?q=互斥锁&spm=1001.2101.3001.7020)（或锁），仅允许一个线程持有*Python*解释器的控制权。

这意味着在任何时间点只能有一个线程处于执行状态。对于执行单线程程序的开发人员而言，GIL的影响并不明显，但它可能是CPU绑定和多线程代码的性能瓶颈。

常见的程序开发中，计算操作需要使用CPU多核优势，IO操作不需要利用CPU的多核优势，所以，就有这一句话：

- 计算密集型，用多进程，例如：大量的数据计算【累加计算示例】。
- IO密集型，用多线程，例如：文件读写、网络数据传输【下载抖音视频示例】。

### 线程常用的方法

`_thread = threading.Thread(target = func, args=())`：创建一个线程

`_thread.start()`：启动一个线程

`_thread.join()`：等待一个进程结束再向下进行

![image-20220407160417894](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220407160417894.png)

`_thread.setdaemon`：守护进程，必须放在`_thread.start()`前面定义

- `_thread.setDaemon(True)`，设置为守护线程，主线程执行完毕后，子线程也自动关闭。
- `_thread.setDaemon(False)`，设置为非守护线程，主线程等待子线程，子线程执行完毕后，主线程才结束。（默认）

![image-20220407161138584](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220407161138584.png)

`_thread_setName()`+`_thread.current_thread().getName()`：设置进程的名字以及获取进程的名字

![image-20220407161743815](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220407161743815.png)

#### 线程安全

一个进程中可以有多个线程，且线程共享所有进程中的资源。多个线程同时去操作一个"东西"，**可能**会存在数据混乱的情况，例如：

```python
import threading
loop = 10000000
number = 0
def _add(count):
    global number
    for i in range(count):
        number += 1
def _sub(count):
    global number
    for i in range(count):
        number -= 1
t1 = threading.Thread(target=_add, args=(loop,))
t2 = threading.Thread(target=_sub, args=(loop,))
t1.start()
t2.start()

t1.join()  # t1线程执行完毕,才继续往后走
t2.join()  # t2线程执行完毕,才继续往后走

print(number)
```

因为两个进程同时分享`global number`这个资源，所以会出现`_add`操作后的值无法及时传给`_sub`，所以这个结果是不确定的

因此我们上锁进行资源的互斥，用到`lock_obj = threading.RLock()`以及`lock_obj.acquire()`,`lock_obj.release()`

```python
import threading
lock_obj = threading.RLock()
loop = 10000000
number = 0


def _add(count):
    global number
    lock_obj.acquire()
    for i in range(count):
        number += 1
    lock_obj.release()

def _sub(count):
    global number
    lock_obj.acquire()
    for i in range(count):
        number -= 1
    lock_obj.acquire()

t1 = threading.Thread(target=_add, args=(loop,))
t2 = threading.Thread(target=_sub, args=(loop,))
t1.start()
t2.start()
t1.join()
t2.join()
# t2线程执行完毕,才继续往后走

print(number)
```

例2:

```python
import threading
num = 0
def task():
    global num
    for i in range(1000000):
        num += 1
    print(num)


for i in range(2):
    t = threading.Thread(target=task)
    t.start()
```

因为两个线程都调用了task里面的资源，所以会出现混乱

```python
import threading
lock_obj = threading.RLock()
num = 0
def task():
  	lock_obj.acquire()
    global num
    for i in range(1000000):
        num += 1
    print(num)
    lock_obj.release()

for i in range(2):
    t = threading.Thread(target=task)
    t.start()
```

#### 线程锁

在程序中如果想要自己手动加锁，一般有两种：`Lock` 和 `RLock`。

- Lock 同步锁

- RLock 递归锁

  ```python
  import threading
  '''Lock同步锁'''
  num = 0
  lock_object = threading.Lock()
  def task():
      print("开始")
      lock_object.acquire()  # 第1个抵达的线程进入并上锁，其他线程就需要再此等待。
      global num
      for i in range(1000000):
          num += 1
      lock_object.release()  # 线程出去，并解开锁，其他线程就可以进入并执行了  
      print(num)
  for i in range(2):
      t = threading.Thread(target=task)
      t.start()
      
  num = 0
  lock_object = threading.RLock()
  
  '''RLock'''  RLock支持多次上锁以及多次释放，Lock不支持
  def task():
      print("开始")
      lock_object.acquire()  # 第1个抵达的线程进入并上锁，其他线程就需要再此等待。
      global num
      for i in range(1000000):
          num += 1
      lock_object.release()  # 线程出去，并解开锁，其他线程就可以进入并执行了
      print(num)
  
  
  for i in range(2):
      t = threading.Thread(target=task)
      t.start()
  ```

  

### 线程池

```python
from concurrent.futures import ThreadPoolExecutor
```

线程池不是越多越好，但是让一个线程完成的任务太多也会降低效率。

```python
import time
from concurrent.futures import ThreadPoolExecutor

# pool = ThreadPoolExecutor(100)
# pool.submit(函数名,参数1，参数2，参数...)


def task(video_url,num):
    print("开始执行任务", video_url)
    time.sleep(5)

# 创建线程池，最多维护10个线程。
pool = ThreadPoolExecutor(10)

url_list = ["www.xxxx-{}.com".format(i) for i in range(300)]

for url in url_list:
# 在线程池中提交一个任务，线程池中如果有空闲线程，则分配一个线程去执行，执行完毕后再将线程交还给线程池；如果没有空闲线程，则等待。
    pool.submit(task, url,2)
    
print("END")
```

![image-20220407222811671](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220407222811671.png)

在线程任务还没结束的时候就执行了后面的语句，所以如果要进行等待，添加`shutdown`

```python
def task(video_url):
    print("开始执行任务", video_url)
    time.sleep(5)


# 创建线程池，最多维护10个线程。
pool = ThreadPoolExecutor(10)

url_list = ["www.xxxx-{}.com".format(i) for i in range(300)]
for url in url_list:
    # 在线程池中提交一个任务，线程池中如果有空闲线程，则分配一个线程去执行，执行完毕后再将线程交还给线程池；如果没有空闲线程，则等待。
    pool.submit(task, url)

print("执行中...")
pool.shutdown(True)  # 等待线程池中的任务执行完毕后，在继续执行
print('继续往下走')
print('END')
```

![image-20220407223103689](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220407223103689.png)

#### 单例模式

单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。

单例模式的要点有三个；一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。

从具体实现角度来说，就是以下三点：一是单例模式的类只提供私有的构造函数，二是类定义中含有一个该类的静态私有对象，三是该类提供了一个静态的共有函数用于创建或获取它本身的静态私有对象。

实现`__new__`方法，然后将类的一个实例绑定到类变量`_instance`上；如果`cls._instance`为None，则说明该类还没有被实例化过，new一个该类的实例，并返回；如果cls._instance不为None，直接返回`_instance`

```python
class Single(object):
    _isintance = None
    def __init__(self,name):
        self.name = name

    def __new__(cls, *args, **kwargs):
        if cls._isintance:
            return cls._isintance
        cls._isintance = object.__new__(cls)
        return cls._isintance

obj = Single('ivan')
print(Single.__new__(obj))
obj2 = Single('lee')
print(Single.__new__(obj2))
```

得到的均为`<__main__.Single object at 0x7f83d31f3130>`，因为`cls._isintance`表示类的属性，所以第一个创建了之后，这个类的`_isintance`就永远为第一个类的地址了，所以`cls._isintance = obj = <__main__.Single object at 0x7f83d31f3130>`

多线程执行单例模式会出错

```python
import threading
class Single(object):
    _isintance = None
    def __init__(self,name):
        self.name = name

    def __new__(cls, *args, **kwargs):
        if cls._isintance:
            return cls._isintance
        cls._isintance = object.__new__(cls)
        return cls._isintance
def task():
    t = Single('ivan')
    print(t)
for i in range(10):
    _thread = threading.Thread(target=task)
    _thread.start()
```

此时由于没有卡顿，在第一个线程执行判断后，新建一个对象区域时，其他进程也可以相继进行判断

![image-20220407230142498](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220407230142498.png)

但如果把时间间隔拉大，

```python
import threading
import time


class Single(object):
    _isintance = None
    def __init__(self,name):
        self.name = name

    def __new__(cls, *args, **kwargs):
        if cls._isintance:
            return cls._isintance
        time.sleep(0.1)
        cls._isintance = object.__new__(cls)
        return cls._isintance
def task():
    t = Single('ivan')
    print(t)
for i in range(10):
    _thread = threading.Thread(target=task)
    _thread.start()
```

![image-20220407230515397](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220407230515397.png)

```python
import threading
import time

class Single(object):
    _isintance = None
    lock_obj = threading.RLock()
    def __init__(self,name):
        self.name = name

    def __new__(cls, *args, **kwargs):
        if cls._isintance:
            return cls._isintance
        with cls.lock_obj:
            if cls._isintance:
                return cls._isintance
            time.sleep(0.1)
            cls._isintance = object.__new__(cls)
            return cls._isintance

def task():
    t = Single('ivan')
    print(t)
for i in range(10):
    _thread = threading.Thread(target=task)
    _thread.start()
```

![image-20220407231033323](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220407231033323.png)

## 进程介绍

进程是计算机中资源分配的最小单元；一个进程中可以有多个线程，同一个进程中的线程共享资源；进程与进程之间则是相互隔离。

所以在不同进程之间，资源是不分享的

```python
import time,multiprocessing

def task():
    print(name)

if __name__ == '__main__':
    name = {}
    _process = multiprocessing.Process(target=task)
    _process.start()
    time.sleep(1)
```

但是结果就是

![image-20220408162820791](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220408162820791.png)

Depending on the platform, [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing) supports three ways to start a process. These *start methods* are

> - *fork*，【“拷贝”几乎所有资源】【支持文件对象/线程锁等传参】【unix】【任意位置开始】【快】
>
>   The parent process uses [`os.fork()`](https://docs.python.org/3/library/os.html#os.fork) to fork the Python interpreter. The child process, when it begins, is effectively identical to the parent process. All resources of the parent are inherited by the child process. Note that safely forking a multithreaded process is problematic.Available on Unix only. The default on Unix.
>
> - *spawn*，【run参数传必备资源】【不支持文件对象/线程锁等传参】【unix、win】【main代码块开始】【慢】
>
>   The parent process starts a fresh python interpreter process. The child process will only inherit those resources necessary to run the process object’s [`run()`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process.run) method. In particular, unnecessary file descriptors and handles from the parent process will not be inherited. Starting a process using this method is rather slow compared to using *fork* or *forkserver*.Available on Unix and Windows. The default on Windows and macOS.
>
> - *forkserver*，【run参数传必备资源】【不支持文件对象/线程锁等传参】【部分unix】【main代码块开始】
>
>   When the program starts and selects the *forkserver* start method, a server process is started. From then on, whenever a new process is needed, the parent process connects to the server and requests that it fork a new process. The fork server process is single threaded so it is safe for it to use [`os.fork()`](https://docs.python.org/3/library/os.html#os.fork). No unnecessary resources are inherited.Available on Unix platforms which support passing file descriptors over Unix pipes.

- `fork`

  ![image-20220408163402518](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220408163402518.png)

  对文件操作也可以：

  ```python
  import time,multiprocessing
  
  def task():
      fb.write('ivan')
      fb.flush()
  
  if __name__ == '__main__':
      name = 'ivan'
      multiprocessing.set_start_method('fork')
      fb = open('x.txt',mode ='a+',encoding='utf8')
      _process = multiprocessing.Process(target=task)
      _process.start()
  ```

  *question*

  ```python
  import multiprocessing
  def task():
      print(name)
      file_object.write("lee\n")
      file_object.flush()
  if __name__ == '__main__':
      multiprocessing.set_start_method("fork")
  
      name = []
      file_object = open('x1.txt', mode='a+', encoding='utf-8')
      file_object.write("ivan\n")
      file_object.flush()
      p1 = multiprocessing.Process(target=task)
      p1.start()
   >>> ivan
  		lee
  		ivan
  ```

  输出结果多了一个ivan是因为执行完`file_object.write("ivan\n")`后没有从内存刷到文件中，所以创建子进程的同时，拷贝了一份这个语句，所以现在子进程中执行了flush，将ivan和lee写入了文件，然后程序结束时再写入主进程的ivan

  修改：

  ```python
  import multiprocessing
  def task():
      print(name)
      file_object.write("lee\n")
      file_object.flush()
  if __name__ == '__main__':
      multiprocessing.set_start_method("fork")
  
      name = []
      file_object = open('x1.txt', mode='a+', encoding='utf-8')
      file_object.write("ivan\n")
      file_object.flush()
      p1 = multiprocessing.Process(target=task)
      p1.start()
  ```

  ```python
  import multiprocessing
  import threading
  import time
  
  def func():
      print("{}来了".format(threading.current_thread().name))
      with lock: #自动获取和释放锁
          print(threading.current_thread().name)
          time.sleep(1)
  
  def task():
      # 拷贝的锁也是被申请走的状态
      # 被谁申请走了? 被子进程中的主线程申请走了
      for i in range(10):
  
          t = threading.Thread(target=func)
          t.setName('thread{}'.format(i))
          t.start()
      time.sleep(2)
      lock.release()
  
  
  if __name__ == '__main__':
      multiprocessing.set_start_method("fork")
      name = []
      lock = threading.RLock()
      lock.acquire()
      p1 = multiprocessing.Process(target=task)
      p1.start()
  ```

  ### 进程常见方法

  `_process.start()`+`_process.join()`+`_process.daemon()`均与线程用法一致

  设置名字：`_process.name = xxx`

  获取名字：`multiprocessing.current_process().name`

  获取当前进程id：`os.getpid()`，获取父进程id：`os.getppid()`

  ```python
  import os,multiprocessing,time
  def task():
      print('{}-{}'.format(multiprocessing.current_process().name,os.getpid()))
      print('父进程id: ',os.getppid())
  if __name__ == "__main__":
      multiprocessing.set_start_method('fork')
      print('{}-{}'.format(multiprocessing.current_process().name,os.getpid()))
      _process = multiprocessing.Process(target=task)
      _process.name = 'sub_process'
      _process.start()
   >>>MainProcess-65352
  		sub_process-65353
  		父进程id:  65352
  ```

  自定义进程类，直接将线程需要做的事写到run方法中。

  ```python
  import multiprocessing
  
  class MyProcess(multiprocessing.Process):
      def run(self):
          print('执行此进程', self._args)
  
  if __name__ == '__main__':
      multiprocessing.set_start_method("spawn")
      p = MyProcess(args=('xxx',))
      p.start()
      print("继续执行...") 
  继续执行...
  执行此进程 ('xxx',)
  ```

  CPU个数，程序一般创建多少个进程？（利用CPU多核优势）

  ```python
  import multiprocessing
  multiprocessing.cpu_count()
  ```

### 进程的数据共享

进程是资源分配的最小单元，每个进程中都维护自己独立的数据，不共享

**Shared memory**

Data can be stored in a shared memory map using [`Value`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Value) or [`Array`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Array). For example, the following code

![image-20220408183516871](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220408183516871.png)

```python
from multiprocessing import Process, Value, Array
```

用法：

```python
from multiprocessing import Value,Process,Array

def func(n, m1, m2):
    print('sub_process')
    print(n.value)
    print(m1.value)
    print(m2.value)
    n.value = 228
    m1.value = 'b'.encode('utf8')
    m2.value = 0.58

if __name__ == '__main__':
    num = Value('i',717)
    v1 = Value('c','a'.encode('utf8'))
    v2 = Value('f',5.8)

    p = Process(target=func, args=(num, v1, v2))
    p.start()
    p.join()
    print('main_process')
    print(num.value)
    print(v1.value)
    print(v2.value)
```

![image-20220408223408391](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220408223408391.png)

```python
from multiprocessing import Value,Process,Array
def func(_array):
    print('sub_process')
    print(_array[:])
    _array[0] = 666

if __name__ == '__main__':

    arr = Array('i',[11,22,33])
    p = Process(target=func, args=(arr,))
    p.start()
    p.join()
    print('main_process')
    print(arr[:])
>>> sub_process
    [11, 22, 33]
    main_process
    [666, 22, 33]
```

如果只输出`_array`或者`arr`，将会返回一个Array对象

 `<SynchronizedArray wrapper for <multiprocessing.sharedctypes.c_int_Array_3 object at 0x7fe460162940>>`

**通过`Manager()`的方法进行分享**

使用multiprocessing下的Manager可以实现服务端的数据共享，多进程同时修改一份数据。

- 共享字典的生成：`manager.dict()`

- 共享列表的生成：`manager.list()`，里面可以默认放置一些数据，如`range（3）`

  ```python
  from multiprocessing import Manager,Process
  def func(_d,_l):
      print('sub_process')
      print(_d)
      print(_l)
      _l.append('AK74')
      _d['name'] = 'ivanlee'
  
  
  if __name__ == '__main__':
      with Manager() as manager:
          _dic = manager.dict()
          _list = manager.list()
          _dic['age'] = 23
          _process = Process(target=func, args=(_dic,_list))
          _process.start()
          _process.join()
          print('main_process')
          print(_dic)
          print(_list)
  >>> sub_process
      {'age': 23}
      []
      main_process
      {'age': 23, 'name': 'ivanlee'}
      ['AK74']
  
  ```

**通过队列`Queue`进行分享**

```python
import multiprocessing


def task(q):
    for i in range(10):
        q.put(i)


if __name__ == '__main__':
    queue = multiprocessing.Queue()

    p = multiprocessing.Process(target=task, args=(queue,))
    p.start()
    p.join()

    print("主进程")
    print(queue.get())
    print(queue.get())
    print(queue.get())
    print(queue.get())
```

### 进程锁

```python
from multiprocessing import Process,Value,current_process
import time

def task(q,):
    q.value += 1
    print(current_process().name)


if __name__ == '__main__':
   v = Value('i',0)
   for i in range(10):
       _process = Process(target=task,args=(v,))
       _process.name = 'process{}'.format(i)
       _process.start()
   time.sleep(2)
   print(v.value)
```

![image-20220408231958618](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220408231958618.png)

如果不上锁，这些程序就会乱来，导致同一时间数据不同步，而且不加`time.sleep()`就会报错

![image-20220408232106232](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220408232106232.png)

实例2:

```python
from multiprocessing import Process,Value,current_process
import time

def task():
    with open('f1.txt',mode='r') as obj:
        current_num = int(obj.read())

    print('{}抢票了'.format(current_process().name))
    current_num -= 1
    time.sleep(1)
    with open('f1.txt', mode='w') as obj:
        obj.write(str(current_num))
        obj.flush()


if __name__ == '__main__':

   for i in range(10):
       _process = Process(target=task)
       _process.name = 'process{}'.format(i)
       _process.start()
```

![image-20220408233259367](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220408233259367.png)

所有人都参与了抢票，理应剩余票数为0 ，但是`f1.txt`里显示9 

所以需要一个互斥锁，

```python
from multiprocessing import Process,Value,current_process
import time

def task():
    lock.acquire()
    with open('f1.txt',mode='r') as obj:
        current_num = int(obj.read())

    print('{}抢票了'.format(current_process().name))
    current_num -= 1
    time.sleep(1)
    with open('f1.txt', mode='w') as obj:
        obj.write(str(current_num))
        obj.flush()
    lock.release()


if __name__ == '__main__':
    multiprocessing.set_start_method('fork')
    lock = multiprocessing.RLock()
    for i in range(10):
       _process = Process(target=task)
       _process.name = 'process{}'.format(i)
       _process.start()
```

如果换成spawn模式，![image-20220408234328515](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220408234328515.png)

### 进程池

```python
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor
```

和线程一样，调用的是sumbit函数

```python
import multiprocessing
from concurrent.futures import ProcessPoolExecutor
import time

def task(i):
    print('执行了{}->{}'.format(multiprocessing.current_process().name,i))
    time.sleep(2)


if __name__ == '__main__':
    _process = ProcessPoolExecutor(4)
    for i in range(10):
        _process.submit(task,i)
```

![image-20220408234854676](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220408234854676.png)

`_process.shutdown(True)`保证子进程结束以后再进行后续的操作

![image-20220408235109847](/Users/ivanlee/Library/Application Support/typora-user-images/image-20220408235109847.png)

